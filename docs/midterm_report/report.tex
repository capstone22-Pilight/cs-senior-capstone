\documentclass[oneside,openright]{book}
\usepackage{listings}
\usepackage{underscore}
\usepackage[breaklinks]{hyperref}
\usepackage{url}
\usepackage{breakurl}
\usepackage{atbegshi} % http://ctan.org/pkg/atbegshi
\AtBeginDocument{\AtBeginShipoutNext{\AtBeginShipoutDiscard}}
\renewcommand\thesection{\arabic{section}}
\renewcommand{\bibname}{References}
\lstset{ %
   language=C++,                % choose the language of the code
   basicstyle=\small,        % the size of the fonts that are used for the code
   keywordstyle=\color{blue},
   stringstyle=\color{red},
   commentstyle=\color{green},
   numbers=left,                   % where to put the line-numbers
   numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
   stepnumber=1,                   % the step between two line-numbers. If it is 1 e ach line will be numbered
   numbersep=5pt,                  % how far the line-numbers are from the code
   backgroundcolor=\color{white},  % choose the background color. You must add \usep ackage{color}
   showspaces=false,               % show spaces adding particular underscores
   showstringspaces=false,         % underline spaces within strings
   showtabs=false,                 % show tabs within strings adding particular unde rscores
   frame=single,           % adds a frame around the code
   tabsize=2,          % sets default tabsize to 2 spaces
   captionpos=b,           % sets the caption-position to bottom
   breaklines=true,        % sets automatic line breaking
   breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
   escapeinside={\%*}{*)}          % if you want to add a comment within your codey
   }
\hypersetup{
    bookmarks=false, % show bookmarks bar?
    pdftitle={Software Requirement Specification}, % title
    pdfauthor={Malcom Diller, Evan Steele, Sean Rettig}, % author
    pdfsubject={Raspberry Pi Outdoor Lighting}, % subject of the document
    pdfkeywords={TeX, LaTeX, graphics, images}, % list of keywords
    colorlinks=true, % false: boxed links; true: colored links
    linkcolor=blue, % color of internal links
    citecolor=black, % color of links to bibliography
    filecolor=black, % color of file links
    urlcolor=blue, % color of external links
  %linktoc=page % only page is linked
}
\def\myversion{1.0 }
\title{
	\flushright
		\rule{16cm}{5pt}\vskip1cm
		\Huge{MIDTERM REPORT}\\
	for\\
		\vspace{2cm}
	Not Exactly the Internet of Things for Outdoor Lighting\\
		\vspace{2cm}
	\LARGE{Progress Report:}
	\vspace{2cm}
	\LARGE{Alpha Stage\\}
	\vspace{2cm}
	Malcolm Diller, Sean Rettig, and Evan Steele\\
        Client: Victor Hsu\\
        OSU CS Senior Capstone Group 22
		\vfill
		\rule{16cm}{5pt}
}

\date{}
\usepackage{hyperref}
\renewcommand{\contentsname}{PiLight}
\begin{document}
\pagenumbering{gobble}
\maketitle
\tableofcontents
\newpage
\pagenumbering{arabic}
\section{Introduction}

\section{Status}

At this point in the project, all alpha-level features have been implemented;
all planned user interface pages and their corresponding elements have been
created and at least stubbed; not all elements are fully functional yet.
However, many of the elements are already at beta-level functionality:

\begin{itemize}
    \item The ESP firmware has been written and can automatically connect to
        the Pi wirelessly.
    \item The Pi is loaded with our custom build of Yocto Linux and can act as
        a wireless router for the ESPs to connect to.
    \item The Pi is set up to run our Flask web site, and it can be connected 
        to by wireless devices and viewed in a browser.
    \item The flask website has an SQL database that stores information about 
        the lights, groups, devices, and users
    \item The web interface has a main page that lists all available lights,
        where lights can be renamed and sorted into groups.
    \item Groups in the main page can also be created, renamed, nested into 
        each other, and deleted, though deletion has not been fully implemented yet.
    \item The web interface has an advanced page for each light/group where
        rules for when to automatically toggle on/off can be created.
    \item All types of rules (including time of day, day of week, day of month,
        day of year, specific dates, sunrise/sunset times, and even parent
        interaction and offsets/staggering) are available to be created.
    \item The web interface has a login screen.
    \item The web interface has a device pairing screen.
\end{itemize}

\section{Work in Progress}
\subsection{Device Communication}
One of the current post-Alpha goals is to complete the communication mechanism between the Raspberry Pi and the ESP8266 modules. We are working on finalizing our logical evaluation subsystem and determining what do to in the case of manual user override. The databases and communication parameters have been completed, as in we know what the function that will flip the lights themselves expects, but we don't know how to perform our Python-based evaluations yet. We expect that it will come shortly after finishing up the advanced query editor, at which point we expect to have a format and value range locked down for the queries to be evaluated.\\

The devices are already prepared in a database to draw from, using the MAC address as the unique key to locate the IP address from the table. We don't anticipate the ISC DHCP server flipping addresses around, but by using the physical hardware addresses we are eliminating any possibility of sending the code to the wrong device. The Python ISC DHCP library provides us with a mechanism for determining if a device's IP has changed, and we will write that change to the devices table.
\section{Problems}
\subsection{Wireless}
We had an issue early on with how we planned to connect to the ESP8266 modules using our Raspberry Pi. Our proof-of-concept had the client connecting to the wireless module itself to make changes, but we wanted remote management to work from the Pi and have it be reachable from the internet. We began looking into ways to perform local routing so that the device could play with the end-user's home network, but ran into more snags trying to configure multiple wireless network devices on the same Pi. We contacted our client who suggested that we not worry about external connectivity for the project. His expectations were that users would directly connect to the Pi to make configuration changes. The project title was "not \textit{exactly} the Internet-of-Things", after all.\\

To fix the issue, we reconfigured the Raspberry Pi so we could connect wirelessly. We needed to first recompile \textit{hostapd} to run with a version of our USB wireless driver that could broadcast an SSID. After recompiling we confirmed that we could connect using a wireless device such as a smartphone. The other task was to change the firmware on the ESP8266 so that it behaves like a client instead of a host. In addition to flashing the new firmware, a startup file was added so that it automatically connects to the nearest Raspberry Pi with "Pilight" in the SSID. We will likely change this later to better incorporate new devices.

\subsection{Pulse Width Modulation}
We had the idea that a device managable via the Raspberry Pi would be able to control the brightness of the lights using PWM. Unfortunately the 10A gates on our relay just can't flip fast enough for any desired pulses. Our group contacted our client to see if it was worth the trouble of acquiring a relay unit that could do PWM, but his response was that he was only concerned with turning the devices on and off. We also considered a software-defined PWM solution, but were again affected by the speed of the relay itself not being sufficient.

\subsection{Behavior of On/Off Switches}
Before starting to implement the rules, we had not put much thought into what the behavior should be for the On/Off switches of the lights and groups. After we began to implement more of the project we realized that there are a few ways that the behavior could be implemented:
\begin{enumerate}
  \item Toggling the switch would change the state of the light until the user chose to resume automated control
  \item Toggling the switch would change the state of the light for a preset amount of time before resuming automated control.
  \item Toggling the switch would change the state of the light until the next time that the rules determined the light should change, upon which automated control would resume.
\end{enumerate}
The are benefits to each implementation and it was a difficult decision to figure out which path we should take. The first option makes sense because the user is never overridden by the system. The second option is useful because the user most likely is turning on the light for a temporary purpose, and probably will not want to have to go into the advanced settings all the time. We decided to go with the third option, as it provided the benifits of the second option, but more cleanly eases back into the pattern of automated control.

\section{Code}
\subsection{Acquire New Devices}
This code, upon user request, scans currently connected devices for a new ESP8266 device that does not already exist in the devices database.
\begin{lstlisting}
   // Get all DHCP leases currently given out
   leases = IscDhcpLeases('/var/lib/dhcp/dhcpd.leases')
   leases = leases.get()

   // No DHCP leases at all, the server is not operating
   if not leases:
      return "NODHCP"

   additions = 0
   // For each lease, first see if it is an ESP8266
   for iteration,lease in enumerate(leases):
      if(ESP8266_check(lease.ip)):
      // We have an ESP8266 mode!
         database_check = model.Device.query.filter_by(mac=lease.ethernet).first()
         if database_check is None:
         // We have an ESP8266 AND it is not in the database!
            new_device = model.Device(mac=lease.ethernet,ipaddr=lease.ip,name="ESP8266@"+lease.ethernet)
            model.db.session.add(new_device)
            model.db.session.commit()
            additions = additions + 1
      return str(additions)
   \end{lstlisting}
\subsection{Editing Lights and Groups}
We decided to use the X-editable library for executing inline edits to the names of groups and lights. This involved creating a span element to represent the name with information about the light or group embedded in it. We then included a few lines of javascript to specify where to send the post request and setup the editable span element. When submitted, a post request would be sent to the flask server. Below is the flask function that handles the post request and changes the name of a light or group in the database.
\begin{lstlisting}
@app.route('/change_name', methods=['POST'])
def change_name():
    name = request.form['value']
    pk = request.form['pk']
    isLight = request.form['name'] == "light"
    if isLight:
        light = model.Light.query.filter_by(id=pk).first()
        light.name = name
    else:
        group = model.Group.query.filter_by(id=pk).first()
        group.name = name
    model.db.session.commit()
    return "Success!"
\end{lstlisting}
\newpage
\Urlmuskip=0mu plus 1mu\relax
\bibliography{design}{}
\bibliographystyle{IEEEtran}

\end{document}
